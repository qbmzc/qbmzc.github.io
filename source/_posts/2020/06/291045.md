---
title: HotSpot虚拟机对象
date: 2020-06-29
categories:
  - Java
tags:
  - java
prev: 181429.md
next: 300957.md
---

![wallhaven-kwq166](https://fastly.jsdelivr.net/gh/qbmzc/images/1593412734_20200629143847666_1349223599.jpg)

## 环境

`HotSpot`虚拟机

`new`关键字

## 对象的创建

1. 判断对像对应的类是否加载、链接、初始化。
2. 为对象分配内存
3. 处理并发 CAS/TLAB --通过-XX:+UseTLAB参数来设置（8默认启用）
4. 初始化分配到的空间---所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用
5. 设置对象的对象头
6. 执行init方法进行初始化

当`Java`虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。

- 指针碰撞（Bump the Pointer）：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。

- 空闲列表（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理（Compact）功能决定。因此，在使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效。而使用CMS这种基于清除（Sweep）算法的收集器时，理论上通常采用空闲列表。（设计的有分配缓冲区，可以在里面使用指针碰撞）

虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。

另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。

虚拟机要对对象进行必要的设置，头信息。

构造函数，一般来说（`Java`编译器会在`new`同时生成`new`和`invokespecial`两条字节码指令，如果通过其他方式产生的则不一定如此），`new`指令之后会接着执行`<init>()`方法。

>以上内容来自《深入理解Java虚拟机第三版》

## 对象的内存布局

![202111272131991](https://gitee.com/snowyan/img2022/raw/master/2022/202111272131991.png)

## 对象的访问定位

![202111272130480](https://gitee.com/snowyan/img2022/raw/master/2022/202111272130480.png)
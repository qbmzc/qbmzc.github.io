---
title: SonarQube 扫描支持多 JDK 版本的实践方案
date: 2025-11-11 13:36:09
tags:
  - SonarQube
  - JDK
  - CI/CD
  - Docker
categories:
  - DevOps
toc: true
---

在企业级项目中，不同的应用可能使用不同的 JDK 版本。如何在 CI/CD 流程中优雅地支持多版本 JDK 的 SonarQube 代码扫描？本文分享一套基于 Docker 的实践方案。

<!-- more -->

## 背景

随着 Java 生态的发展，企业内部往往存在多个 JDK 版本并行的情况：
- 老项目仍在使用 JDK 8
- 新项目已经升级到 JDK 17 或 21
- 部分项目尝鲜 JDK 23/25

在 CI/CD 流程中，我们需要根据项目的 JDK 版本选择对应的编译和扫描环境，确保代码质量检查的准确性。

## 方案设计

### 核心思路

为每个 JDK 版本构建独立的 Docker 镜像，镜像中包含：
- 对应版本的 JDK
- Maven 构建工具
- SonarQube Scanner

在 CI/CD 流程中，根据项目配置动态选择对应的镜像进行构建和扫描。

### 优势

- **隔离性好**：每个版本独立，互不干扰
- **镜像体积小**：单个镜像只包含一个 JDK 版本
- **易于维护**：版本升级只需重新构建对应镜像
- **灵活性高**：可以为不同版本配置不同的工具链

## 实施步骤

### 1. 构建基础镜像

以 JDK 21 为例，创建 `Dockerfile.jdk21`：

```dockerfile
# 基础镜像已经包含了 Maven 和 Sonar Scanner
FROM java-maven-builder:sonar-jdk

# 安装 JDK 21
COPY jdk21.tar.gz /tmp/
RUN tar -xzf /tmp/jdk21.tar.gz -C /opt/ && \
    mv /opt/jdk-21* /opt/jdk21 && \
    rm /tmp/jdk21.tar.gz

# 注意：这里不设置 JAVA_HOME，在运行时通过环境变量动态指定
# 这样可以保持镜像的灵活性
# ENV JAVA_HOME=/opt/jdk21
# ENV PATH=$JAVA_HOME/bin:$PATH
```

**说明**：
- 基础镜像 `java-maven-builder:sonar-jdk` 已包含 Maven 和 SonarQube Scanner
- 只需添加对应版本的 JDK
- 不在镜像中固定 `JAVA_HOME`，保持运行时的灵活性

### 2. 批量构建脚本

创建 `build-all.sh` 脚本，一键构建所有版本的镜像：

```bash
#!/bin/bash
# 构建脚本 - 为每个 JDK 版本构建独立镜像

set -e

# 配置参数
REGISTRY="images.cc.com/library"
IMAGE_NAME="sonar-scanner"
VERSIONS=("1.8" "11" "17" "21" "23" "25")

echo "=========================================="
echo "开始构建 Sonar Scanner 镜像"
echo "=========================================="
echo ""

# 遍历所有版本进行构建
for version in "${VERSIONS[@]}"; do
    echo ">>> 构建 JDK ${version} 镜像..."
    
    # 构建镜像，同时打上版本标签和日期标签
    docker build \
        -f Dockerfile.jdk${version} \
        -t ${REGISTRY}/${IMAGE_NAME}:jdk${version} \
        -t ${REGISTRY}/${IMAGE_NAME}:jdk${version}-$(date +%Y%m%d) \
        .
    
    echo "✓ JDK ${version} 镜像构建完成"
    echo ""
done

echo "=========================================="
echo "所有镜像构建完成！"
echo "=========================================="
echo ""
echo "镜像列表："
for version in "${VERSIONS[@]}"; do
    echo "  - ${REGISTRY}/${IMAGE_NAME}:jdk${version}"
    echo "  - ${REGISTRY}/${IMAGE_NAME}:jdk${version}-$(date +%Y%m%d)"
done
echo ""
echo "推送镜像到仓库："
for version in "${VERSIONS[@]}"; do
    echo "  docker push ${REGISTRY}/${IMAGE_NAME}:jdk${version}"
done
```

**使用方法**：

```bash
# 赋予执行权限
chmod +x build-all.sh

# 执行构建
./build-all.sh

# 推送到镜像仓库
docker push images.cc.com/library/sonar-scanner:jdk1.8
docker push images.cc.com/library/sonar-scanner:jdk11
# ... 其他版本
```


### 3. 集成到 CI/CD 流程

在 CI/CD 代码中，根据项目的 JDK 版本动态选择镜像和配置环境变量：

```java
/**
 * 根据 JDK 版本配置构建环境
 * @param jdkVersion JDK 版本号（如 "1.8", "11", "17" 等）
 * @return 镜像名称
 */
public String configureBuildEnvironment(String jdkVersion) {
    String sourceJavaHome;
    
    // 根据 JDK 版本设置 JAVA_HOME 路径
    switch (jdkVersion) {
        case "1.8":
            sourceJavaHome = "/usr/java/jdk1.8.0_202";
            break;
        case "11":
            sourceJavaHome = "/opt/jdk11";
            break;
        case "17":
            sourceJavaHome = "/usr/java/jdk-17.0.5";
            break;
        case "21":
            sourceJavaHome = "/opt/jdk21";
            break;
        case "23":
            sourceJavaHome = "/opt/jdk23";
            break;
        case "25":
            sourceJavaHome = "/opt/jdk25";
            break;
        default:
            // 默认使用 JDK 8
            sourceJavaHome = "/usr/java/jdk1.8.0_202";
            log.warn("未识别的 JDK 版本: {}, 使用默认版本 1.8", jdkVersion);
            break;
    }
    
    // 设置环境变量
    System.setProperty("JAVA_HOME", sourceJavaHome);
    
    // 动态选择镜像
    String imageName = "images.cc.com/library/sonar-scanner:jdk" + jdkVersion;
    log.info("使用镜像: {}, JAVA_HOME: {}", imageName, sourceJavaHome);
    
    return imageName;
}
```

**GitLab CI 配置示例**：

```yaml
sonar-scan:
  stage: test
  image: ${SONAR_IMAGE}
  variables:
    JAVA_HOME: ${JAVA_HOME_PATH}
  script:
    - mvn clean verify sonar:sonar
      -Dsonar.projectKey=${CI_PROJECT_NAME}
      -Dsonar.host.url=${SONAR_HOST_URL}
      -Dsonar.login=${SONAR_TOKEN}
  only:
    - merge_requests
    - main
```

## 方案对比

在实际应用中，还有其他几种可选方案，各有优劣：

### 方案一：单镜像包含所有 JDK 版本

**实现方式**：在一个镜像中安装所有需要的 JDK 版本。

**优点**：
- 只需维护一个镜像
- 切换版本只需修改环境变量

**缺点**：
- ❌ 镜像体积非常大（可能超过 2GB）
- ❌ 构建时间长
- ❌ 拉取镜像慢，影响 CI/CD 效率
- ❌ 资源浪费，每次只用一个 JDK

### 方案二：挂载 JDK 目录

**实现方式**：在宿主机或 PVC 中预先上传 JDK，容器启动时挂载。

**优点**：
- 镜像体积小
- 灵活性高

**缺点**：
- ❌ 需要在每个构建节点上维护 JDK 文件
- ❌ 依赖外部存储，增加复杂度
- ❌ 权限管理复杂
- ❌ 不适合云原生环境

### 方案三：使用官方 JDK 镜像从头构建

**实现方式**：基于官方 JDK 镜像，每次构建时安装 Maven 和 SonarQube Scanner。

```dockerfile
FROM eclipse-temurin:17-jdk-alpine

# 安装构建工具
RUN apk add --no-cache \
    maven \
    sonar-scanner-cli \
    git \
    bash

WORKDIR /workspace

# 配置 Maven 镜像源（可选）
COPY settings.xml /root/.m2/settings.xml
```

**优点**：
- ✅ 使用官方维护的 JDK 镜像，安全性高
- ✅ 镜像体积相对较小
- ✅ 易于理解和维护

**缺点**：
- ❌ 每次构建需要下载依赖
- ❌ 构建时间较长
- ❌ 需要为每个版本维护独立的 Dockerfile

### 方案四：多阶段构建（推荐）

**实现方式**：结合本文方案，使用 Docker 多阶段构建优化镜像。

```dockerfile
# 构建阶段
FROM maven:3.8-eclipse-temurin-17 AS builder
WORKDIR /build
COPY pom.xml .
RUN mvn dependency:go-offline

# 运行阶段
FROM eclipse-temurin:17-jdk-slim
COPY --from=builder /root/.m2 /root/.m2
RUN apt-get update && \
    apt-get install -y maven sonar-scanner && \
    rm -rf /var/lib/apt/lists/*
```

**优点**：
- ✅ 镜像体积最小
- ✅ 构建速度快
- ✅ 安全性高

## 方案选择建议

| 场景 | 推荐方案 |
|------|---------|
| 企业内部，版本固定 | 本文方案（独立镜像） |
| 云原生环境 | 方案四（多阶段构建） |
| 快速验证 | 方案三（官方镜像） |
| 资源受限 | 方案二（挂载目录） |


## 最佳实践

### 1. 镜像标签管理

```bash
# 使用语义化版本标签
images.cc.com/library/sonar-scanner:jdk17-v1.0.0

# 同时维护 latest 标签
images.cc.com/library/sonar-scanner:jdk17-latest

# 添加构建日期标签便于追溯
images.cc.com/library/sonar-scanner:jdk17-20251111
```

### 2. 镜像安全扫描

```bash
# 使用 Trivy 扫描镜像漏洞
trivy image images.cc.com/library/sonar-scanner:jdk17

# 集成到 CI/CD 流程
docker scan images.cc.com/library/sonar-scanner:jdk17
```

### 3. 缓存优化

在 Dockerfile 中合理利用缓存层：

```dockerfile
# 先复制依赖配置文件
COPY pom.xml /workspace/
RUN mvn dependency:go-offline

# 再复制源代码
COPY src /workspace/src
RUN mvn package
```

### 4. 环境变量配置

```bash
# 在 CI/CD 中统一管理环境变量
export JAVA_HOME=/opt/jdk17
export MAVEN_OPTS="-Xmx2048m -XX:MaxPermSize=512m"
export SONAR_SCANNER_OPTS="-Xmx1024m"
```

## 总结

通过为每个 JDK 版本构建独立的 Docker 镜像，我们实现了：

1. **灵活的版本管理**：支持多个 JDK 版本并行使用
2. **高效的 CI/CD 流程**：镜像体积小，拉取速度快
3. **良好的可维护性**：版本隔离，互不影响
4. **标准化的构建环境**：确保构建结果的一致性

这套方案已在生产环境稳定运行，有效支撑了企业内部多版本 Java 项目的代码质量管理。

## 参考资料

- [SonarQube 官方文档](https://docs.sonarqube.org/)
- [Docker 多阶段构建最佳实践](https://docs.docker.com/build/building/multi-stage/)
- [Eclipse Temurin JDK 镜像](https://hub.docker.com/_/eclipse-temurin)
- [Maven Docker 镜像](https://hub.docker.com/_/maven)

---

*如果你的团队也面临多 JDK 版本管理的挑战，希望这篇文章能给你一些启发！*
